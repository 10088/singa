// This file is auto-generated, do not edit manually.
// If any error occurs during compilation, please refer to clsrc_to_str.py
#include <string>

namespace singa {

std::string pooling_str = "// This file is modified from the file located at\n// https://github.com/BVLC/caffe/blob/opencl/src/caffe/greentea/cl_kernels/pooling.cl\n// and is covered under the BSD 2-Clause License, as indicated in the LICENSE\n// file at the root of this repository.\n\n__kernel void max_pool_forward(\n    const int nthreads, __global const float* bottom, const int channels, \n    const int height, const int width,\n    const int pooled_h, const int pooled_w,\n    const int kernel_h, const int kernel_w,\n    const int stride_h, const int stride_w,\n    const int pad_h, const int pad_w,\n    __global float* top, __global float* mask) {\n\n//  printf(\"%d \", get_global_size(0));\n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    const int pw = i % pooled_w;\n    const int ph = (i / pooled_w) % pooled_h;\n    const int c = (i / pooled_w / pooled_h) % channels;\n    const int n = i / pooled_w / pooled_h / channels;\n    \n    int hstart = ph * stride_h - pad_h;\n    int wstart = pw * stride_w - pad_w;\n    const int hend = min(hstart + kernel_h, height);\n    const int wend = min(wstart + kernel_w, width);\n    hstart = max(hstart, (int)0);\n    wstart = max(wstart, (int)0);\n    \n    float maxval = -FLT_MAX;\n    int maxidx = -1;\n    __global const float* bottom_slice = bottom + (n * channels + c) * height * width;\n    for (int h = hstart; h < hend; ++h) {\n      for (int w = wstart; w < wend; ++w) {\n        const int index = h * width + w;\n        if (bottom_slice[index] > maxval) {\n          maxidx = index;\n          maxval = bottom_slice[maxidx];\n        }\n      }\n    }\n    top[i] = maxval;\n    mask[i] = (float)maxidx;\n  }\n}\n\n__kernel void ave_pool_forward(\n    const int nthreads, __global const float* const bottom, const int channels, \n    const int height, const int width,\n    const int pooled_h, const int pooled_w,\n    const int kernel_h, const int kernel_w,\n    const int stride_h, const int stride_w, \n    const int pad_h, const int pad_w, __global float* top) {\n    \n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    const int pw = i % pooled_w;\n    const int ph = (i / pooled_w) % pooled_h;\n    const int c = (i / pooled_w / pooled_h) % channels;\n    const int n = i / pooled_w / pooled_h / channels;\n    int hstart = ph * stride_h - pad_h;\n    int wstart = pw * stride_w - pad_w;\n    int hend = min(hstart + kernel_h, height + pad_h);\n    int wend = min(wstart + kernel_w, width + pad_w);\n    const int pool_size = (hend - hstart) * (wend - wstart);\n    hstart = max(hstart, (int)0);\n    wstart = max(wstart, (int)0);\n    hend = min(hend, height);\n    wend = min(wend, width);\n    float aveval = 0;\n    __global const float* bottom_slice = bottom + (n * channels + c) * height * width;\n    for (int h = hstart; h < hend; ++h) {\n      for (int w = wstart; w < wend; ++w) {\n        aveval += bottom_slice[h * width + w];\n      }\n    }\n    top[i] = aveval / pool_size;\n  }\n}\n\n__kernel void sto_pool_forward_train(\n    const int nthreads, __global const float* bottom,\n    const int channels, const int height, const int width,\n    const int pooled_h, const int pooled_w, const int kernel_h,\n    const int kernel_w, const int stride_h, const int stride_w,\n    __global float* rand_idx, __global float* top) {\n    \n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    const int pw = i % pooled_w;\n    const int ph = (i / pooled_w) % pooled_h;\n    const int c = (i / pooled_w / pooled_h) % channels;\n    const int n = i / pooled_w / pooled_h / channels;\n    \n    const int hstart = ph * stride_h;\n    const int hend = min(hstart + kernel_h, height);\n    const int wstart = pw * stride_w;\n    const int wend = min(wstart + kernel_w, width);\n    float cumsum = 0.;\n    __global const float* bottom_slice = bottom + (n * channels + c) * height * width;\n    // First pass: get sum\n    for (int h = hstart; h < hend; ++h) {\n      for (int w = wstart; w < wend; ++w) {\n        cumsum += bottom_slice[h * width + w];\n      }\n    }\n    const float thres = rand_idx[i] * cumsum;\n    // Second pass: get value, and set i.\n    cumsum = 0;\n    for (int h = hstart; h < hend; ++h) {\n      for (int w = wstart; w < wend; ++w) {\n        cumsum += bottom_slice[h * width + w];\n        if (cumsum >= thres) {\n          rand_idx[i] = ((n * channels + c) * height + h) * width + w;\n          top[i] = bottom_slice[h * width + w];\n          h = hend;\n          w = wend;\n        }\n      }\n    }\n  }\n}\n\n__kernel void sto_pool_forward_test(\n    const int nthreads, __global const float* const bottom, const int channels, \n    const int height, const int width,\n    const int pooled_h, const int pooled_w, \n    const int kernel_h, const int kernel_w, \n    const int stride_h, const int stride_w,\n    __global float* top) {\n    \n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    const int pw = i % pooled_w;\n    const int ph = (i / pooled_w) % pooled_h;\n    const int c = (i / pooled_w / pooled_h) % channels;\n    const int n = i / pooled_w / pooled_h / channels;\n    \n    const int hstart = ph * stride_h;\n    const int hend = min(hstart + kernel_h, height);\n    const int wstart = pw * stride_w;\n    const int wend = min(wstart + kernel_w, width);\n    // We set cumsum to be 0 to avoid divide-by-zero problems\n    float cumsum = FLT_MIN;\n    float cumvalues = 0.;\n    __global const float* bottom_slice = bottom + (n * channels + c) * height * width;\n    // First pass: get sum\n    for (int h = hstart; h < hend; ++h) {\n      for (int w = wstart; w < wend; ++w) {\n        cumsum += bottom_slice[h * width + w];\n        cumvalues += bottom_slice[h * width + w] * bottom_slice[h * width + w];\n      }\n    }\n    top[i] = cumvalues / cumsum;\n  }\n}\n\n__kernel void max_pool_backward(const int nthreads,\n                                __global const float* top_diff,\n                                __global const float* mask,\n                                const int channels,\n                                const int height, const int width,\n                                const int pooled_h, const int pooled_w,\n                                const int kernel_h, const int kernel_w,\n                                const int stride_h, const int stride_w,\n                                const int pad_h, const int pad_w,\n                                __global float* bottom_diff) {\n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    // find out the local i\n    // find out the local offset\n    const int w = i % width;\n    const int h = (i / width) % height;\n    const int c = (i / width / height) % channels;\n    const int n = i / width / height / channels;\n    \n    const int phstart =\n        (h + pad_h < kernel_h) ? 0 : (h + pad_h - kernel_h) / stride_h + 1;\n    const int phend = min((h + pad_h) / stride_h + 1, pooled_h);\n    const int pwstart =\n        (w + pad_w < kernel_w) ? 0 : (w + pad_w - kernel_w) / stride_w + 1;\n    const int pwend = min((w + pad_w) / stride_w + 1, pooled_w);\n    float gradient = 0.0f;\n    const int offset = (n * channels + c) * pooled_h * pooled_w;\n    __global const float* top_diff_slice = top_diff + offset;\n    __global const float* mask_slice = mask + offset;\n    for (int ph = phstart; ph < phend; ++ph) {\n      for (int pw = pwstart; pw < pwend; ++pw) {\n        if (mask_slice[ph * pooled_w + pw] == (float)(h * width + w)) {\n          gradient += top_diff_slice[ph * pooled_w + pw];\n        }\n      }\n    }\n    bottom_diff[i] = gradient;\n  }\n}\n\n__kernel void ave_pool_backward(const int nthreads,\n                                __global const float* top_diff,\n                                const int channels,\n                                const int height, const int width,\n                                const int pooled_h, const int pooled_w,\n                                const int kernel_h, const int kernel_w,\n                                const int stride_h, const int stride_w,\n                                const int pad_h, const int pad_w,\n                                __global float* bottom_diff) {\n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    // find out the local i\n    // find out the local offset\n    const int w = i % width + pad_w;\n    const int h = (i / width) % height + pad_h;\n    const int c = (i / width / height) % channels;\n    const int n = i / width / height / channels;\n    \n    const int phstart = (h < kernel_h) ? 0 : (h - kernel_h) / stride_h + 1;\n    const int phend = min(h / stride_h + 1, pooled_h);\n    const int pwstart = (w < kernel_w) ? 0 : (w - kernel_w) / stride_w + 1;\n    const int pwend = min(w / stride_w + 1, pooled_w);\n    float gradient = 0.0;\n    __global const float* const top_diff_slice = top_diff + (n * channels + c) * pooled_h * pooled_w;\n    for (int ph = phstart; ph < phend; ++ph) {\n      for (int pw = pwstart; pw < pwend; ++pw) {\n        // figure out the pooling size\n        int hstart = ph * stride_h - pad_h;\n        int wstart = pw * stride_w - pad_w;\n        int hend = min(hstart + kernel_h, height + pad_h);\n        int wend = min(wstart + kernel_w, width + pad_w);\n        int pool_size = (hend - hstart) * (wend - wstart);\n        gradient += top_diff_slice[ph * pooled_w + pw] / pool_size;\n      }\n    }\n    bottom_diff[i] = gradient;\n  }\n}\n\n__kernel void sto_pool_backward(\n    const int nthreads, __global const float* rand_idx,\n    __global const float* const top_diff, const int channels,\n    const int height, const int width,\n    const int pooled_h, const int pooled_w,\n    const int kernel_h, const int kernel_w,\n    const int stride_h, const int stride_w,\n    __global float* bottom_diff) {\n\n  for (int i = get_global_id(0); i < nthreads; i += get_global_size(0)) {\n    // find out the local i\n    // find out the local offset\n    const int w = i % width;\n    const int h = (i / width) % height;\n    const int c = (i / width / height) % channels;\n    const int n = i / width / height / channels;\n    \n    const int phstart = (h < kernel_h) ? 0 : (h - kernel_h) / stride_h + 1;\n    const int phend = min(h / stride_h + 1, pooled_h);\n    const int pwstart = (w < kernel_w) ? 0 : (w - kernel_w) / stride_w + 1;\n    const int pwend = min(w / stride_w + 1, pooled_w);\n    float gradient = 0.0;\n    __global const float* rand_idx_slice = rand_idx + (n * channels + c) * pooled_h * pooled_w;\n    __global const float* top_diff_slice = top_diff + (n * channels + c) * pooled_h * pooled_w;\n    for (int ph = phstart; ph < phend; ++ph) {\n      for (int pw = pwstart; pw < pwend; ++pw) {\n        gradient += top_diff_slice[ph * pooled_w + pw]\n            * (i == (int) (rand_idx_slice[ph * pooled_w + pw])?1.0:0.0);\n      }\n    }\n    bottom_diff[i] = gradient;\n  }\n}\n\n";

} // namespace singa