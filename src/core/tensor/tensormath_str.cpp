// This file is auto-generated, do not edit manually.
// If any error occurs during compilation, please refer to clsrc_to_str.py
#include <string>

namespace singa {

std::string tensormath_str = "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// **************************************\n// Element-wise functions\n// **************************************\n\n// Sum is basically reduction.\n// This reduction code is serial reduction modified from AMD\'s example.\n// http://developer.amd.com/resources/documentation-articles/articles-whitepapers/opencl-optimization-case-study-simple-reductions/\n__kernel\nvoid clkernel_fabs(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = fabs(in[i]);\n}\n\n__kernel\nvoid clkernel_add_scalar(const int num, float x, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in[i] + x;\n}\n\n__kernel\nvoid clkernel_add(const int num, __global const float* in1, __global const float* in2,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in1[i] + in2[i];\n}\n\n__kernel\nvoid clkernel_clamp(const int num, float low, float high, __global const float* in,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = clamp(in[i], low, high);\n}\n\n__kernel\nvoid clkernel_divide_scalar_matx(const int num, __global const float* in1, const float x,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in1[i] / x;\n}\n\n__kernel\nvoid clkernel_divide_scalar_xmat(const int num, const float x, __global const float* in1,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = x / in1[i];\n}\n\n__kernel\nvoid clkernel_divide(const int num, __global const float* in1, __global const float* in2,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in1[i] / in2[i];\n}\n\n__kernel\nvoid clkernel_eltmult_scalar(const int num, const float x, __global const float* in,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in[i] * x;\n}\n\n__kernel\nvoid clkernel_eltmult(const int num, __global const float* in1, __global const float* in2,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in1[i] * in2[i];\n}\n\n__kernel\nvoid clkernel_exp(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = exp(in[i]);\n}\n\n__kernel\nvoid clkernel_le(const int num, __global const float* in, const float x,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = (in[i] <= x) ? 1.0f : 0.0f;\n}\n\n__kernel\nvoid clkernel_log(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = log(in[i]);\n}\n\n__kernel\nvoid clkernel_lt(const int num, __global const float* in, const float x,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = (in[i] < x) ? 1.0f : 0.0f;\n}\n\n__kernel\nvoid clkernel_ge(const int num, __global const float* in, const float x,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = (in[i] >= x) ? 1.0f : 0.0f;\n}\n\n__kernel\nvoid clkernel_gt(const int num, __global const float* in, const float x,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = (in[i] > x) ? 1.0f : 0.0f;\n}\n\n__kernel\nvoid clkernel_pow_scalar(const int num, const float x, __global const float* in,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = pow(in[i], x);\n}\n\n__kernel\nvoid clkernel_pow(const int num, __global const float* in1, __global const float* in2,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = pow(in1[i], in2[i]);\n}\n\n__kernel\nvoid clkernel_relu(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = (in[i] >= 0.0f) ? in[i] : 0.0f;\n}\n\n__kernel\nvoid clkernel_set(const int num, const float x, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = x;\n}\n\n__kernel\nvoid clkernel_sigmoid(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = 1 / (1 + exp(-(in[i])));\n}\n\n__kernel\nvoid clkernel_sign(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = (in[i] > 0) - (in[i] < 0);\n}\n\n__kernel\nvoid clkernel_sqrt(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = sqrt(in[i]);\n}\n\n// kernel for square is called pow(2).\n\n__kernel\nvoid clkernel_subtract_scalar(const int num, __global const float* in, const float x,\n  __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in[i] - x;\n}\n\n__kernel\nvoid clkernel_subtract(const int num, __global const float* in1, __global const float* in2,\n   __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = in1[i] - in2[i];\n}\n\n// reduce3 kernel from\n// https://github.com/sschaetz/nvidia-opencl-examples/blob/master/OpenCL/src/oclReduction/oclReduction_kernel.cl\n__kernel\nvoid clkernel_sum(const int num, __global const float* in, __global float* out,\n  __local float* sdata) {\n  const int i = get_group_id(0)*(get_local_size(0)*2) + get_local_id(0);\n  const int tid = get_local_id(0);\n  sdata[tid] = (i < num) ? in[i] : 0.0f;\n\n  // Perform the first level of reduction.\n  if (i + get_local_size(0) < num) {\nsdata[tid] += in[i + get_local_size(0)];\n  }\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  for (int s = get_local_size(0)/2; s > 0; s >>= 1) {\nif (tid > s) {\n  sdata[tid] += sdata[tid + s];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n  }\n\n  if (tid == 0) {\nout[get_group_id(0)] = sdata[0];\n  }\n}\n\n__kernel\nvoid clkernel_tanh(const int num, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = tanh(in[i]);\n}\n\n// **************************************\n// Random functions\n// **************************************\n\n// See: distribution.cl\n\n// *********************************************************\n// BLAS functions, ref to http://docs.nvidia.com/cuda/cublas\n// *********************************************************\n\n__kernel\nvoid clkernel_amax(const int num, __global const float* in, __global int* ret,\n   __local uint* sdata, __local size_t* temp) {\n  const int gid = get_global_id(0);\n  const int tid = get_local_id(0);\n\n  for(int s = get_local_size(0)/2; s > 0; s >>= 1) {\nif (tid < s) {\n  sdata[tid] = (in[sdata[tid]] > in[tid+s]) ? sdata[tid] : tid;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n  }\n  if (tid == 0) {\nret[0] = sdata[0];\n  }\n}\n\n\n/* TODO: Fix line 284:20.\n__kernel\nvoid clkernel_amin(const int num, __global const float* in, __global int* ret,\n   __local float* sdata, __local size_t* temp) {\n  const int gid = get_global_id(0);\n  const int tid = get_local_id(0);\n\n  // Initialize the values to pos infinity.\n  sdata[tid] = (gid < num) ? in[gid] : INFINITY;\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  for(int s = get_local_size(0)/2; s > 0; s >>= 1) {\nif (tid < s) {\n  sdata[tid] = (in[sdata[tid]] < in[tid+s]) ? sdata[tid] : tid;\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n  }\n  if (tid == 0) {\nret[0] = sdata[0];\n  }\n}*/\n\n\n__kernel\nvoid clkernel_asum(const int num, __global const float* in, __global float* out,\n   __local float* sdata) {\n  const int tid = get_local_id(0);\n  const int i = get_global_id(0);\n\n  // Initialize\n  sdata[tid] = (i < num) ? in[i] : INFINITY;\n  // Perform the first level of reduction.\n  if (i + get_local_size(0) < num) {\nsdata[tid] += in[i + get_local_size(0)];\n  }\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  for(int s = get_local_size(0)/2; s > 0; s >>= 1) {\nif (tid < s) {\n  sdata[tid] = fabs(sdata[tid + s]);\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n  }\n  if (tid == 0) {\nout[0] = sdata[0];\n  }\n}\n\n__kernel\nvoid clkernel_axpy(const int num, float alpha, __global const float* in,\n   __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = fma(alpha, in[i], out[i]);\n}\n\n// This kernel is essentially the same as Sum, except that during the process\n// of reading in data to the local memory, the value is also doubled.\n// Then, just before submitting the sum to out, we do a square-root on it.\n__kernel\nvoid clkernel_nrm2(const int num, __global const float* in, __global float* out,\n   __local float* sdata) {\n  const int i = get_group_id(0)*(get_local_size(0)*2) + get_local_id(0);\n  const int tid = get_local_id(0);\n  sdata[tid] = (i < num) ? (in[i] * in[i]) : 0.0f;\n\n  // Perform the first level of reduction.\n  if (i + get_local_size(0) < num) {\nsdata[tid] += in[i + get_local_size(0)];\n  }\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  for (int s = get_local_size(0)/2; s > 0; s >>= 1) {\nif (tid > s) {\n  sdata[tid] += sdata[tid + s];\n}\nbarrier(CLK_LOCAL_MEM_FENCE);\n  }\n\n  if (tid == 0) {\nout[get_group_id(0)] = sqrt(sdata[0]);\n  }\n}\n\n__kernel\nvoid clkernel_scale(const int num, float x, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  out[i] = x * out[i];\n}\n\n__kernel\nvoid clkernel_dot(const int num, __global const float* in1, __global const float* in2,\n    __global float* out, __local float* scratch) {\n  const int i = get_global_id(0);\n  if (i >= num) return;\n  int offset = i << 2;\n  scratch[i] = in1[offset] * in2[offset];\n\n}\n\n// First kernel from http://www.bealto.com/gpu-gemv_intro.html\n// y = \xce\xb1*A*v + \xce\xb2*y\n// fma(a, b, c) == (a * b) + c with infinite precision\n__kernel\nvoid clkernel_gemv(const int m, const int n, const float alpha,\n   __global const float* A, __global const float* v,\n   const float beta, __global float* out) {\n  const int i = get_global_id(0);\n  float sum  = 0.0f;\n  for (int k = 0; k < n; k++) {\n    sum += fma(beta, out[i + m * k], alpha * A[i + m * k] * v[k]);\n  }\n  out[i] = sum;\n}\n\n// http://docs.nvidia.com/cuda/cublas/#cublas-lt-t-gt-dgmm\n// X[j] = x[j*inc(x)] if inc(x) \xe2\x89\xa5 0\n//= x[(\xcf\x87 \xe2\x88\x92 1)*|inc(x)| \xe2\x88\x92 j*|inc(x)|] if inc(x) < 0\n\n// C = diag( X )*A\n__kernel\nvoid clkernel_dgmm_left(const int nrow, const int ncol,\n__global const float* M, __global const float* v,\n__global float* out) {\n  const uint gidx = get_global_id(0);\n\n  uint offset = gidx * ncol;\n  for (uint i = 0; i < ncol; i++) {\nout[offset + i] = M[offset + i] * v[i];\n  }\n}\n\n// C = A*diag( X )\n__kernel\nvoid clkernel_dgmm_right(const int nrow, const int ncol,\n __global const float* M, __global const float* v,\n __global float* out) {\n  const uint gidx = get_global_id(0);\n\n  uint offset = gidx * ncol;\n  for (uint i = 0; i < ncol; i++) {\nout[offset + i] = M[offset + i] * v[gidx];\n  }\n}\n\n// TODO: Optimize with Reference from http://www.cedricnugteren.nl/tutorial.php?page=1\n//  C = \xce\xb1*A*B + \xce\xb2*C\n__kernel\nvoid clkernel_gemm(const uint nrowA, const uint ncolB, const uint ncolA, const float alpha,\n    __global const float* A, __global const float* B, const float beta,\n     __global float* C, __local float* Asub, __local float* Bsub) {\n\n  const uint lidx = get_local_id(0);\n  const uint lidy = get_local_id(1);\n  const uint TS = get_local_size(0); // Tile size\n  const uint gidx = TS * get_group_id(0) + lidx; // Row ID of C (0..M)\n  const uint gidy = TS * get_group_id(1) + lidy; // Row ID of C (0..N)\n\n  // Initialise the accumulation register\n  float acc = 0.0f;\n\n  // Loop over all tiles\n  const int numtiles = ncolA / TS;\n  for (int t = 0; t < numtiles; t++) {\n    const int tiledRow = TS * t + lidx;\n    const int tiledCol = TS * t + lidy;\n    Asub[lidy * TS + lidx] = A[tiledCol * nrowA + gidx];\n    Bsub[lidy * TS + lidx] = B[gidy * ncolA + tiledRow];\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    for(int k = 0; k < TS; k++) {\n      acc += Asub[k * TS + lidx] * Bsub[lidy * TS + k] * alpha;\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n  }\n\n  C[gidy * nrowA + gidx] = fma(beta, C[gidy * nrowA + gidx], acc);\n}\n\n\n__kernel\nvoid clkernel_crossentropy(const uint batchsize, const uint dim,\n   __global const float* p, __global const int* t,\n   __global float* loss) {\n  const uint gidx = get_global_id(0);\n  if (gidx >= batchsize) return;\n\n  int truth_idx = t[gidx];\n  if (truth_idx <= 0) return;\n  float prob_of_truth = p[gidx * dim + truth_idx];\n  loss[gidx] = -log(fmax(prob_of_truth, -FLT_MIN));\n}\n\n\n__kernel\nvoid clkernel_softmaxentropy(const uint batchsize, const uint dim,\n __global const float* p, __global const int* t,\n __global float* grad) {\n  const uint gidx = get_global_id(0);\n  if (gidx >= batchsize) return;\n\n  int truth_idx = t[gidx];\n  if (truth_idx <= 0) return;\n  grad[gidx * dim + truth_idx] -= 1.0;\n}\n\n\n__kernel\nvoid clkernel_rowmax(const uint nrow, const uint ncol,\n                     __global const float* in, __global float* out) {\n  const uint row_id = get_global_id(0);\n  if (row_id >= nrow) return;\n\n  float row_max_val = -FLT_MAX;\n  for (uint i = 0; i < ncol; i++) {\n    row_max_val = fmax(row_max_val, in[row_id * ncol + i]);\n  }\n\n  out[row_id] = row_max_val;\n}\n\n\n// **************************************\n// Matrix functions\n// **************************************\n/*\n__kernel\nvoid clkernel_addcol(int nrow, int ncol, __global const float* A, __global const float* v, __global float* out) {\n  const int i = get_global_id(0);\n  const int j = get_global_id(1);\n  if (i >= nrow) return;\n  if (j >= ncol) return;\n  ret[j] = A[j + nrow * i] + v[j];\n}\n\n__kernel\nvoid clkernel_addrow(int nrow, int ncol, __global const float* A, __global const float* v, __global float* out) {\n  const int i = get_global_id(0);\n  const int j = get_global_id(1);\n  if (i >= nrow) return;\n  if (j >= ncol) return;\n  out[i] = A[i + ncol * j] + v[i];\n}\n\n__kernel\nvoid clkernel_outerproduct(int m, const int n, __global const float* in1, __global const float* in2, __global float* out) {\n  const int col = get_global_id(0);\n  const int row = get_global_id(1);\n\n  // TODO: This\n}\n\n__kernel\nvoid clkernel_sumcol(int nrow, int ncol, __global const float* in, __global float* out) {\n  const int i = get_global_id(0);\n  if (i >= nrow) return;\n\n  float sum = 0.0f;\n  for (int j = 0; j < nrow; j++) {\nsum += input[nrow * i + j];\n  }\n  out[i] = sum;\n}\n*/\n__kernel\nvoid clkernel_sumrow(int nrow, int ncol, __global const float* in, __global float* out) {\n  const int idx = get_global_id(0);\n  if (idx >= nrow) return;\n\n  float sum = 0.0f;\n  for (int j = 0; j < ncol; j++) {\nsum += in[j + ncol * idx];\n  }\n  out[idx] = sum;\n}\n\n\n// Adapted from http://code.haskell.org/HsOpenCL/tests/bench/transpose.cl\n#define BLOCK_DIM 16\n__kernel\nvoid clkernel_transpose(uint nrow, uint ncol,\n__global const float* in, __global float* out,\n__local float* sdata) {\n  uint gidx = get_global_id(0);\n  uint gidy = get_global_id(1);\n\n  if ((gidx < ncol) && (gidy < nrow)) {\nuint id_in = gidy * ncol + gidx;\nsdata[get_local_id(1) * (BLOCK_DIM+1) + get_local_id(0)] = in[id_in];\n  }\n\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  gidx = get_group_id(1) * BLOCK_DIM + get_local_id(0);\n  gidy = get_group_id(0) * BLOCK_DIM + get_local_id(1);\n  if ((gidx < nrow) && (gidy < ncol)) {\nuint id_out = gidy * nrow + gidx;\nout[id_out] = sdata[get_local_id(0) * (BLOCK_DIM + 1) + get_local_id(1)];\n  }\n}\n/*\n__kernel\nvoid clkernel_transpose2(uint nrow, uint ncol, __global const float* in, __global float* out, __local float* sdata) {\n  const uint lidx = get_local_id(0);\n  const uint lidy = get_local_id(1);\n  const uint id0 = get_group_id(0) * ncol * lidx;\n  const uint id1 = get_group_id(1) * nrow * lidy;\n\n  if (id0 < nrow && id1 < ncol) {\nsdata[lidx][lidy] = in[id1 * nrow + id0];\n  }\n\n  barrier(CLK_LOCAL_MEM_FENCE);\n\n  const uint new_id0 = get_group_id(1) * nrow + lidx;\n  const uint new_id1 = get_group_id(0) * ncol + lidy;\n\n  if (new_id0 < ncol && new_id1 < nrow) {\nout[new_id1 * ncol + new_id0] = sdata[lidx][lidy];\n  }\n}*/\n\n__kernel\nvoid clkernel_diagvec_left(uint vsize, __global const float* vin, __global float* out) {\n  const uint gid = get_global_id(0);\n\n  for (uint i = 0; i < vsize; i++)\nout[gid * vsize + i] = (i == gid) ? vin[gid] : 0.0f;\n}\n\n\n__kernel\nvoid clkernel_diagvec_right(uint vsize, __global const float* vin, __global float* out) {\n  const uint gid = get_global_id(0);\n\n  for (uint i = 0; i < vsize; i++)\nout[gid * vsize + i] = (i == gid) ? vin[gid] : 0.0f;\n}\n";

} // namespace singa